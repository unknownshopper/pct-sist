<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PCT2 - Registro de Inspecciones, Calibraciones y Otros 2023</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    .topbar { position: sticky; top: 0; display: flex; align-items: center; gap: 12px; padding: 10px 14px; background:#fff; border-bottom:1px solid var(--steel-300); z-index: 40; }
    .brand { font-weight: 800; color: var(--accent); text-decoration: none; }
    .nav-toggle { margin-left: auto; display: none; background: transparent; border: 1px solid var(--steel-400); padding: 6px 10px; border-radius: 8px; }
    .nav-links { list-style: none; display: flex; gap: 12px; margin: 0; padding: 0; flex-wrap: wrap; }
    .nav-links a { text-decoration: none; color: var(--text-200); font-weight: 600; padding: 6px 8px; border-radius: 8px; }
    .nav-links a[aria-current="page"] { background: rgba(11,179,217,0.08); color: var(--accent); }
    .user-badge { position: relative; right: 0; top: 0; margin-left: auto; display:none; align-items: center; gap: 8px; padding: 6px 10px; border: 1px solid rgba(2,132,199,0.25); border-radius: 999px; background: #fff; color: var(--text-300); font-weight: 600; }
    .user-avatar { width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, var(--accent-2), var(--accent)); }
    .user-menu { position: absolute; right: 0; top: calc(100% + 6px); display: none; min-width: 180px; background:#fff; border:1px solid var(--steel-400); border-radius: 10px; box-shadow: var(--shadow); padding: 6px; }
    .user-menu a, .user-menu button { width: 100%; display: block; text-align: left; padding: 8px 10px; border: none; background: none; color: var(--text-200); text-decoration: none; border-radius: 8px; cursor: pointer; }
    .user-menu a:hover, .user-menu button:hover { background: rgba(2,132,199,0.08); }
    .user-badge.open .user-menu { display: block; }
    @media (max-width: 760px) { .nav-toggle { display: inline-block; } .nav-links { position: absolute; left:0; right:0; top:54px; background:#fff; border-bottom:1px solid var(--steel-300); display:none; flex-direction:column; padding:8px; } .nav-links.open { display:flex; } }
    main { position: relative; max-width: 1600px; margin: 0 auto; padding: 16px; }
    h1 { margin: 6px 0 2px; }
    .sub { color: var(--muted); margin: 0 0 12px; }
    .toolbar { display: flex; gap: 8px; align-items: center; margin: 12px 0; flex-wrap: wrap; }
    .toolbar input, .toolbar select, .toolbar button { height: 36px; border: 1px solid var(--steel-400); border-radius: 10px; padding: 6px 10px; font: inherit; }
    .toolbar input { flex: 1; min-width: 220px; }
    .meta { font-size: 12px; color: var(--text-300); margin-bottom: 8px; }
    .scroll-top { overflow-x: auto; overflow-y: hidden; height: 14px; margin: 0 0 6px; }
    .scroll-spacer { height: 1px; }
    .table-wrap { position: relative; overflow: auto; border: 1px solid var(--steel-400); border-radius: 10px; background: #fff; max-height: 72vh; box-shadow: var(--shadow); }
    table.data { width: max-content; border-collapse: collapse; min-width: 1200px; }
    table.data th, table.data td { padding: 8px 10px; border-bottom: 1px solid rgba(15,23,42,0.08); text-align: left; background: #fff; white-space: nowrap; }
    table.data thead th { position: sticky; top: 0; background: var(--bg-800); z-index: 2; white-space: nowrap; user-select: none; cursor: pointer; }
    table.data thead th:first-child { left: 0; z-index: 4; }
    table.data td:first-child, table.data th:first-child { position: sticky; left: 0; box-shadow: 1px 0 0 rgba(15,23,42,0.08); background: #fff; }
    th.sortable::after { content: '\25B4\25BE'; font-size: 10px; opacity: 0.5; margin-left: 6px; }
    th.sorted.asc::after { content: '\25B4'; }
    th.sorted.desc::after { content: '\25BE'; }
    .muted { color: var(--muted); }
    .badge { display:inline-block; padding:2px 6px; border-radius:6px; background:#eef2ff; border:1px solid #c7d2fe; color:#3730a3; font-size: 12px; }
    .tip { position: fixed; z-index: 60; pointer-events: none; background: #0f172a; color:#fff; font-size:12px; padding:6px 8px; border-radius: 8px; box-shadow: 0 6px 16px rgba(2,132,199,0.18); max-width: 320px; }
    .summary-card { border:1px solid var(--steel-400); border-radius: 10px; padding: 12px; margin-top: 10px; background:#fff; box-shadow: var(--shadow); }
    .summary-head { display:flex; align-items:center; gap:12px; margin-bottom:8px; }
    .summary-head select { height: 32px; border:1px solid var(--steel-400); border-radius:8px; padding:4px 8px; }
    .kpi { margin-left:auto; display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:10px; background:#fef2f2; color:#991b1b; border:1px solid #fecaca; font-weight:700; }
    .bar { position: relative; height: 16px; border-radius: 999px; overflow: hidden; background: #f1f5f9; border:1px solid var(--steel-300); }
    .seg { height: 100%; display: inline-block; }
    .seg.exp { background:#ef4444; }
    .seg.d30 { background:#f59e0b; }
    .seg.d60 { background:#10b981; }
    .seg.ok { background:#22c55e; }
    .legend { display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; }
    .legend span { display:inline-flex; align-items:center; gap:6px; }
    .dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
    .dot.exp { background:#ef4444; }
    .dot.d30 { background:#f59e0b; }
    .dot.d60 { background:#10b981; }
    .dot.ok { background:#22c55e; }
    /* Top KPI banner */
    .top-kpi { position: sticky; top: 48px; z-index: 39; display:flex; gap:16px; align-items:center; margin: 10px 0 12px; padding: 12px 16px; border:1px solid var(--steel-400); border-radius: 12px; background: linear-gradient(180deg, #ffffff, #f8fafc); box-shadow: var(--shadow); }
    .kpi-chip { display:inline-flex; align-items:center; gap:8px; padding:8px 14px; border-radius:999px; font-weight:800; font-size: 15px; border:1px solid var(--steel-300); background:#fff; }
    .kpi-chip.exp { background:#fef2f2; color:#991b1b; border-color:#fecaca; }
    .kpi-chip.prox { background:#fff7ed; color:#9a3412; border-color:#fed7aa; }
    .kpi-chip.mid { background:#ecfdf5; color:#065f46; border-color:#bbf7d0; }
    .kpi-chip.miss { background:#eef2ff; color:#3730a3; border-color:#c7d2fe; }
  </style>
  <script type="module" src="firebase-init.js"></script>
</head>
<body>
  <nav class="topbar" aria-label="Principal">
    <a class="brand" href="primaria.html">PCT</a>
    <button id="navToggle" class="nav-toggle" aria-expanded="false" aria-controls="navMenu" aria-label="Abrir menú">☰</button>
    <ul id="navMenu" class="nav-links">
      <li><a href="primaria.html">Primaria</a></li>
      <li><a href="inslis.html">Registro</a></li>
      <li><a href="intop.html">Aproximaciones</a></li>
      <li><a href="ingral.html">Inventario</a></li>
      <li><a href="tareas.html">Tareas</a></li>
      <li><a href="pct2.html">PCT2</a></li>
      <li><a href="index.html">Admin</a></li>
      <li><a href="opciones.html">Opciones</a></li>
    </ul>
    <div id="userBadge" class="user-badge" style="display:none">
      <div class="user-avatar"></div>
      <span id="userName">Usuario</span>
      <div class="user-menu" id="userMenu" role="menu" aria-hidden="true">
        <a href="opciones.html" role="menuitem">Opciones</a>
        <button id="logoutMenuItem" type="button" role="menuitem">Cerrar sesión</button>
      </div>
    </div>
  </nav>
  <main>
    <h1>PCT2 – Registro 2023</h1>
    <p class="sub">Visualización del archivo CSV “PCT2-FR-039 - REGISTRO DE INSPECCIONES CALIBRACIONES Y OTROS 2023.csv”.</p>

    <div id="meta" class="meta"></div>

    <div class="top-kpi" id="topKPI" aria-live="polite">
      <span class="kpi-chip miss">No realizados: <strong id="kpiTopMiss">0</strong></span>
      <span class="kpi-chip exp">Vencidos: <strong id="kpiTopExp">0</strong></span>
      <span class="kpi-chip prox">Próximos (<=30 días): <strong id="kpiTopProx">0</strong></span>
      <span class="kpi-chip mid">Próximos (<=60 días): <strong id="kpiTop60">0</strong></span>
    </div>
    <div class="toolbar">
      <input id="search" type="search" placeholder="Buscar en la tabla (NC, Estado, Equipo/Activo, Descripción, etc.)">
      <select id="sortCol">
        <option value="">Ordenar por…</option>
      </select>
      <select id="dateCol" title="Columna de fecha" style="min-width:220px">
        <option value="">Columna de fecha…</option>
      </select>
      <button id="btnAsc" type="button">Asc</button>
      <button id="btnDesc" type="button">Desc</button>
      <button id="btnExport" class="btn" type="button">Exportar vista (CSV)</button>
      <button id="btnSave" class="btn btn-primary" type="button">Guardar</button>
      <button id="btnPrint" class="btn" type="button">Imprimir / PDF</button>
    </div>

    <div class="scroll-top" id="scrollTop"><div class="scroll-spacer" id="scrollTopInner"></div></div>
    <div class="table-wrap" id="tableWrap">
      <table class="data" id="tbl">
        <thead><tr id="thead"></tr></thead>
        <tbody id="tbody"><tr><td class="muted">Cargando…</td></tr></tbody>
      </table>
    </div>
    <div id="summaryCard" class="summary-card">
      <div class="summary-head">
        <strong>Vigencia</strong>
        <span id="kpiVencidos" class="kpi" title="Registros vencidos" style="display:none">0 vencidos</span>
      </div>
      <div class="bar" id="bar"></div>
      <div class="legend" id="legend"></div>
    </div>
  </main>

  <script src="script.js?v=3"></script>
  <script>
    (function(){
      function unlock(){
        try {
          document.body.classList.remove('locked');
          var main = document.querySelector('main'); if (main) main.removeAttribute('inert');
          var ov = document.getElementById('lockOverlay'); if (ov) ov.style.display='none';
        } catch {}
      }
    try { window.updateTopKPIFromDOM = updateTopKPIFromDOM; } catch {}
    // Helper: recompute top KPI from current DOM (used on live edit)
    function updateTopKPIFromDOM(){
      try {
        const idxs = window._pct2_colIdx || {};
        const trs = Array.from(document.querySelectorAll('#tbody tr'));
        if (trs.length && Number.isInteger(idxs.real) && Number.isInteger(idxs.fecha)){
          let miss=0, exp=0, d30=0, d60=0, ok=0;
          for (const tr of trs){
            const tds = Array.from(tr.children);
            const realVal = tds[idxs.real]?.textContent || '';
            const proxVal = tds[idxs.fecha]?.textContent || '';
            const tReal = parseDate(realVal);
            if (!realVal || isNaN(tReal)) { miss++; continue; }
            let dias = null;
            if (Number.isInteger(idxs.dias) && idxs.dias < tds.length){
              const raw = tds[idxs.dias]?.textContent || '';
              const n = Number(String(raw).replace(/,/g,''));
              dias = isFinite(n) ? n : null;
            }
            if (dias == null){
              const tProx = parseDate(proxVal);
              const now = new Date();
              const tToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
              if (!isNaN(tProx)) dias = Math.floor((tProx - tToday)/(1000*60*60*24));
            }
            if (dias == null) continue;
            if (dias < 0) exp++; else if (dias <= 30) d30++; else if (dias <= 60) d60++; else ok++;
          }
          const elMiss = document.getElementById('kpiTopMiss');
          const elExp = document.getElementById('kpiTopExp');
          const elProx = document.getElementById('kpiTopProx');
          const el60  = document.getElementById('kpiTop60');
          if (elMiss) elMiss.textContent = String(miss);
          if (elExp) elExp.textContent = String(exp);
          if (elProx) elProx.textContent = String(d30);
          if (el60)  el60.textContent  = String(d60);
          try { console.log('[pct2] KPI counts (DOM)', {miss, exp, d30, d60, ok}); } catch {}
          return;
        }
        // Fallback to header-based summary
        const headers = getHeaders();
        const viewRows = trs.map(tr => Array.from(tr.children).map(td => td.textContent || ''));
        renderSummary(headers, viewRows);
      } catch {}
    }

    

    function detectBestDateColBySample(tbody){
      try {
        const trs = Array.from((tbody||document.getElementById('tbody'))?.querySelectorAll('tr')||[]);
        if (!trs.length) return -1;
        const cols = trs[0].children.length;
        let bestIdx = -1, bestHits = -1;
        for (let c=0;c<cols;c++){
          let hits=0, seen=0;
          for (let r=0; r<Math.min(30, trs.length); r++){
            const txt = trs[r].children[c]?.textContent || '';
            if (txt){ seen++; if (!isNaN(parseDate(txt))) hits++; }
          }
          if (seen>0 && hits>bestHits){ bestHits = hits; bestIdx = c; }
        }
        return (bestHits>0) ? bestIdx : -1;
      } catch { return -1; }
    }

    function recalcVigencia(headers, rows){
      try {
        if (!Array.isArray(headers) || !Array.isArray(rows)) return rows;
        let idxFecha = -1, idxDias = -1;
        headers.forEach((h,i)=>{
          const n = norm(h);
          if (idxFecha<0 && (n.includes('proxima') || n.includes('próxima'))) idxFecha = i;
          if (idxDias<0 && (n.includes('dias') || n.includes('días')) && n.includes('vigencia')) idxDias = i;
        });
        if (idxFecha < 0 || idxDias < 0) return rows;
        return rows.map(r => {
          const d = daysUntil(r[idxFecha]);
          const out = r.slice();
          out[idxDias] = (d==null || isNaN(d)) ? '' : String(d);
          return out;
        });
      } catch { return rows; }
    }

    function daysUntil(dateStr){
      const t = parseDate(dateStr);
      if (isNaN(t)) return null;
      const now = Date.now();
      const diff = Math.floor((t - now) / (1000*60*60*24));
      return diff;
    }

    function vigenciaDays(fechaProxStr, fechaRealStr){
      try {
        const tProx = parseDate(fechaProxStr);
        const now = new Date();
        const tToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        if (isNaN(tProx)) return null;
        const diff = Math.floor((tProx - tToday) / (1000*60*60*24));
        return diff;
      } catch { return null; }
    }
    try { window.vigenciaDays = vigenciaDays; } catch {}

    function norm(s){ return String(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); }

    function renderSummary(headers, viewRows){
      const bar = document.getElementById('bar');
      const legend = document.getElementById('legend');
      if (!bar || !legend) return;
      bar.innerHTML=''; legend.innerHTML='';
      if (!Array.isArray(headers) || !Array.isArray(viewRows) || !viewRows.length) return;
      // Detect columns (exact-first, then includes, then DOM fallback)
      let idxTipo = -1, idxFecha = -1, idxDias = -1, idxReal = -1;
      try {
        headers.forEach((h,i)=>{
          const n = String(h||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim();
          if (idxTipo<0 && (n === 'tipo de prueba' || n === 'tipo')) idxTipo = i;
          if (idxFecha<0 && n === 'proxima prueba') idxFecha = i;
          if (idxDias<0 && n === 'dias de vigencia') idxDias = i;
          if (idxReal<0 && n === 'fecha realizacion') idxReal = i;
        });
        headers.forEach((h,i)=>{
          const n = String(h||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
          if (idxFecha<0 && (n.includes('proxima')||n.includes('próxima')) && n.includes('prueba')) idxFecha=i;
          if (idxDias<0 && (n.includes('dias')||n.includes('días')) && n.includes('vigencia')) idxDias=i;
          if (idxReal<0 && n.includes('fecha') && (n.includes('realizacion')||n.includes('realización'))) idxReal=i;
          if (idxTipo<0 && (n.includes('tipo de prueba') || n==='tipo')) idxTipo = i;
        });
      } catch {}
      // DOM-based fallback (best date-looking column) if needed
      if (idxReal < 0) idxReal = detectBestDateColBySample(document.getElementById('tbody'));
      if (idxFecha < 0) idxFecha = detectBestDateColBySample(document.getElementById('tbody'));
      try { console.log('[pct2] summary indices', { idxReal, idxFecha, idxDias, idxTipo }); } catch {}
      // Count buckets
      const counts = { miss:0, exp:0, d30:0, d60:0, ok:0 };
      const perTipo = new Map(); // tipo => {exp,d30,d60,ok}
      function addTipo(tipo, bucket){
        if (!perTipo.has(tipo)) perTipo.set(tipo, { exp:0, d30:0, d60:0, ok:0 });
        perTipo.get(tipo)[bucket]++;
      }
      for (const row of viewRows){
        // Missing or unparsable FECHA REALIZACIÓN => No realizados
        if (idxReal>=0){
          const realVal = row[idxReal];
          const tReal = parseDate(realVal);
          if (!realVal || isNaN(tReal)) { counts.miss++; continue; }
        }
        let dias = null;
        if (idxDias>=0) {
          const raw = row[idxDias];
          const n = Number(String(raw).replace(/,/g,''));
          dias = isFinite(n) ? n : null;
        }
        if (dias==null && idxFecha>=0) dias = vigenciaDays(row[idxFecha], null);
        if (dias==null) continue;
        let bucket = 'ok';
        if (dias < 0) bucket = 'exp'; else if (dias <= 30) bucket = 'd30'; else if (dias <= 60) bucket = 'd60';
        counts[bucket]++;
        const tipo = idxTipo>=0 ? String(row[idxTipo]||'') : '';
        if (tipo) addTipo(tipo, bucket);
      }
      // Update TOP KPI (sticky) with No realizados, Vencidos, Próximos (<=30) y (<=60)
      try {
        const elMiss = document.getElementById('kpiTopMiss');
        const elExp = document.getElementById('kpiTopExp');
        const elProx = document.getElementById('kpiTopProx');
        const el60  = document.getElementById('kpiTop60');
        if (elMiss) elMiss.textContent = String(counts.miss);
        if (elExp) elExp.textContent = String(counts.exp);
        if (elProx) elProx.textContent = String(counts.d30);
        if (el60)  el60.textContent  = String(counts.d60);
        try { console.log('[pct2] KPI counts', counts); } catch {}
      } catch {}
      const total = counts.exp + counts.d30 + counts.d60 + counts.ok;
      const kpi = document.getElementById('kpiVencidos');
      if (kpi) {
        kpi.textContent = String(counts.exp) + ' vencidos';
        kpi.style.display = 'inline-flex';
      }
      const mkSeg = (cls, n) => {
        const w = total ? (n/total*100) : 0;
        const div = document.createElement('div');
        div.className = 'seg '+cls; div.style.width = w+'%';
        bar.appendChild(div);
      };
      mkSeg('exp', counts.exp); mkSeg('d30', counts.d30); mkSeg('d60', counts.d60); mkSeg('ok', counts.ok);
      const item = (cls, label, n) => {
        const span = document.createElement('span');
        span.innerHTML = `<i class="dot ${cls}"></i>${label}: <strong>${n}</strong>`;
        return span;
      };
      legend.appendChild(item('exp','Vencidos',counts.exp));
      legend.appendChild(item('d30','<=30 días',counts.d30));
      legend.appendChild(item('d60','<=60 días',counts.d60));
      legend.appendChild(item('ok','>60 días',counts.ok));
      // Per-tipo quick summary chips
      if (perTipo.size){
        const brk = document.createElement('div'); brk.style.flexBasis='100%'; legend.appendChild(brk);
        perTipo.forEach((val, key) => {
          const s = document.createElement('span');
          const sum = val.exp + val.d30 + val.d60 + val.ok;
          s.innerHTML = `<strong>${key}</strong>: ${sum}`;
          s.style.border='1px solid var(--steel-300)';
          s.style.borderRadius='999px';
          s.style.padding='4px 8px';
          legend.appendChild(s);
        });
      }
    }
      // run now and on auth changes
      unlock();
      document.addEventListener('DOMContentLoaded', unlock);
      window.addEventListener('auth:changed', unlock);
    })();
  </script>
  <script>
    const SRC = 'PCT2-FR-039%20-%20REGISTRO%20DE%20INSPECCIONES%20CALIBRACIONES%20Y%20OTROS%202023.csv';
    const $ = (s,c=document)=>c.querySelector(s);
    const $$ = (s,c=document)=>Array.from(c.querySelectorAll(s));

    function detectDelimiter(sample){
      const line = (sample.replace(/\r\n?/g,'\n').split('\n').find(l=>l.trim().length>0)) || '';
      const cands = [',',';','\t','|'];
      let best = { d: ',', n: 0 };
      for (const d of cands){ const n = (line.split(d).length - 1); if (n > best.n) best = { d, n }; }
      return best.d === '\t' ? '\t' : best.d;
    }

    function getHeaders(){
      return Array.from(document.querySelectorAll('#thead th')).map(th => th.textContent.trim());
    }

    function bindTooltips(){
      let tip = document.querySelector('.tip');
      if (!tip) { tip = document.createElement('div'); tip.className='tip'; tip.style.display='none'; document.body.appendChild(tip); }
      const tbody = document.getElementById('tbody');
      if (!tbody) return;
      const headers = getHeaders();
      tbody.addEventListener('mousemove', (e)=>{
        const td = e.target.closest('td');
        if (!td) { tip.style.display='none'; return; }
        const tr = td.parentElement;
        const cIdx = Number(td.dataset.colIndex||-1);
        const rIdx = Number(tr?.dataset?.rowIndex||-1);
        if (cIdx<0 || rIdx<0) { tip.style.display='none'; return; }
        const header = headers[cIdx] || '';
        const value = td.textContent || '';
        tip.innerHTML = `<strong>${header}</strong><br>${value}<br><span class="muted">Fila ${rIdx+1}</span>`;
        tip.style.left = Math.min(e.clientX + 16, window.innerWidth - 220) + 'px';
        tip.style.top = Math.min(e.clientY + 16, window.innerHeight - 60) + 'px';
        tip.style.display='block';
      });
      tbody.addEventListener('mouseleave', ()=>{ const el = document.querySelector('.tip'); if (el) el.style.display='none'; });
    }

    function enhanceScroll(){
      const wrap = document.getElementById('tableWrap');
      if (!wrap) return;
      wrap.addEventListener('wheel', (e) => {
        const dx = Math.abs(e.deltaX), dy = Math.abs(e.deltaY);
        if (dy > dx) { wrap.scrollLeft += e.deltaY; e.preventDefault(); }
      }, { passive: false });
      let isDown = false, startX = 0, startLeft = 0;
      wrap.addEventListener('mousedown', (e) => { isDown = true; startX = e.pageX; startLeft = wrap.scrollLeft; wrap.style.cursor='grabbing'; });
      wrap.addEventListener('mouseleave', () => { isDown = false; wrap.style.cursor=''; });
      wrap.addEventListener('mouseup', () => { isDown = false; wrap.style.cursor=''; });
      wrap.addEventListener('mousemove', (e) => { if (!isDown) return; const dx = e.pageX - startX; wrap.scrollLeft = startLeft - dx; });
    }

    function setupScrollSync(){
      const wrap = document.getElementById('tableWrap');
      const top = document.getElementById('scrollTop');
      const inner = document.getElementById('scrollTopInner');
      const tbl = document.getElementById('tbl');
      if (!wrap || !top || !inner || !tbl) return;
      const width = tbl.scrollWidth;
      inner.style.width = width + 'px';
      let lock = false;
      top.onscroll = () => { if (lock) return; lock = true; wrap.scrollLeft = top.scrollLeft; lock = false; };
      wrap.onscroll = () => { if (lock) return; lock = true; top.scrollLeft = wrap.scrollLeft; lock = false; };
      window.addEventListener('resize', () => { inner.style.width = tbl.scrollWidth + 'px'; });
    }
    function parseCSV(text){
      const delim = detectDelimiter(text);
      const lines = text.replace(/\r\n?/g,'\n').split('\n');
      const rows = [];
      for (const line of lines){
        if (line.length===0) { rows.push(['']); continue; }
        const out = []; let cur=''; let inQ=false;
        for (let i=0;i<line.length;i++){
          const ch = line[i];
          if (ch==='"'){
            if (inQ && line[i+1]==='"'){ cur+='"'; i++; }
            else { inQ = !inQ; }
          } else if (!inQ && ch === (delim==='\t' ? '\t' : delim)){
            out.push(cur); cur='';
          } else { cur+=ch; }
        }
        out.push(cur); rows.push(out);
      }
      return rows;
    }

    function findHeaderIndex(rows){
      // Busca una fila que parezca encabezado; típicamente contiene EQUIPO/ACTIVO o NC
      for (let i=0;i<rows.length;i++){
        const r = rows[i].map(v=>String(v||'').trim());
        if (r.filter(c=>c).length < 2) continue;
        const sig = r.join(' ').toUpperCase();
        if (sig.includes('EQUIPO/ACTIVO') || (r[0].toUpperCase()==='NC' && r.includes('ESTADO'))){
          return i;
        }
      }
      // fallback: primera fila no vacía
      for (let i=0;i<rows.length;i++){ if (rows[i].some(c=>String(c||'').trim())) return i; }
      return 0;
    }

    let sortIndex = -1; let sortDir = 'asc'; // 'asc' | 'desc'

    function render(headers, data){
      const thead = $('#thead'); const tbody = $('#tbody');
      thead.innerHTML = ''; tbody.innerHTML = '';
      headers.forEach((h, i) => { const th = document.createElement('th'); th.textContent = h; th.classList.add('sortable'); th.dataset.index = String(i); if (i===sortIndex){ th.classList.add('sorted'); th.classList.add(sortDir); } thead.appendChild(th); });
      if (!data.length){ tbody.innerHTML = '<tr><td class="muted">Sin datos</td></tr>'; return; }
      let rIdx = 0; const mapIdx = (window._pct2ViewIndices||[]);
      // Detect indices for Próxima fecha, Fecha realización y Días de vigencia
      let idxFecha = -1, idxDias = -1, idxReal = -1;
      try {
        headers.forEach((h,i)=>{
          const n = String(h||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim();
          // exact matches first
          if (idxReal<0 && n === 'fecha realizacion') idxReal = i;
          if (idxFecha<0 && n === 'proxima prueba') idxFecha = i;
          if (idxDias<0 && n === 'dias de vigencia') idxDias = i;
        });
        // fallback by includes
        headers.forEach((h,i)=>{
          const n = String(h||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
          if (idxFecha<0 && (n.includes('proxima') || n.includes('próxima')) && n.includes('prueba')) idxFecha = i;
          if (idxDias<0 && (n.includes('dias') || n.includes('días')) && n.includes('vigencia')) idxDias = i;
          if (idxReal<0 && n.includes('fecha') && (n.includes('realizacion') || n.includes('realización'))) idxReal = i;
        });
      } catch {}
      // Fallbacks por muestreo si no se detectan
      if (idxReal < 0) idxReal = detectBestDateColBySample(document.getElementById('tbody'));
      if (idxFecha < 0) idxFecha = detectBestDateColBySample(document.getElementById('tbody'));
      try { console.log('[pct2] render idxReal, idxFecha, idxDias =', idxReal, idxFecha, idxDias); } catch {}
      // Expose detected indices for other routines (e.g., KPI banner updates)
      try { window._pct2_colIdx = { fecha: idxFecha, real: idxReal, dias: idxDias }; } catch {}
      for (const r of data){
        const tr = document.createElement('tr');
        tr.dataset.rowIndex = String(rIdx++);
        const mi = mapIdx[rIdx-1]; if (mi != null) tr.dataset.masterIndex = String(mi);
        for (let i=0;i<headers.length;i++){
          const td=document.createElement('td');
          try {
            if (idxDias>=0 && idxFecha>=0 && idxReal>=0 && i===idxDias){
              const fechaProx = r[idxFecha];
              const fechaReal = r[idxReal];
              const d = vigenciaDays(fechaProx, fechaReal);
              td.textContent = (d==null || isNaN(d)) ? '' : String(d);
            } else {
              td.textContent = String(r[i] == null ? '' : r[i]);
            }
          } catch {
            // Fallback seguro: valor original
            td.textContent = String(r[i] == null ? '' : r[i]);
          }
          td.dataset.colIndex = String(i);
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      // header click sort
      thead.querySelectorAll('th').forEach(th => {
        th.addEventListener('click', () => {
          const idx = Number(th.dataset.index||'-1'); if (isNaN(idx)) return;
          if (sortIndex === idx) { sortDir = (sortDir==='asc'?'desc':'asc'); } else { sortIndex = idx; sortDir = 'asc'; }
          applyAndRender(headers, dataMaster);
        // Ensure KPI banner reflects current data after first render
        try { setTimeout(updateTopKPIFromDOM, 0); } catch {}
          // sync select
          const sel = $('#sortCol'); if (sel) sel.value = String(sortIndex);
        });
      });
      bindTooltips();
      enhanceScroll();
      setupScrollSync();
      try { renderSummary(headers, data); } catch {}
    }

    function applyFilter(headers, allRows){
      const q = ($('#search').value || '').toLowerCase();
      if (!q) return allRows;
      return allRows.filter(r => r.join(' ').toLowerCase().includes(q));
    }

    function parseDate(s){
      if (!s) return NaN; const str = String(s).trim();
      // Try DD/MM/YYYY HH:MM
      let m = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s+(\d{1,2}):(\d{2}))?/);
      if (m){ const dd=Number(m[1]), mm=Number(m[2])-1, yy=Number(m[3] < 100 ? ('20'+m[3]) : m[3]); const hh=Number(m[4]||'0'), mi=Number(m[5]||'0'); const d=new Date(yy,mm,dd,hh,mi); return d.getTime(); }
      // Try DD-MMM-YY (Spanish months, e.g., 03-feb-23, 26-may-2025)
      const meses = { ene:0, enero:0, feb:1, febrero:1, mar:2, marzo:2, abr:3, abril:3, may:4, mayo:4, jun:5, junio:5, jul:6, julio:6, ago:7, agosto:7, sep:8, sept:8, septiembre:8, oct:9, octubre:9, nov:10, noviembre:10, dic:11, diciembre:11 };
      m = str.match(/^(\d{1,2})[\-\s]([a-zA-Záéíóúñ]+)[\-\s](\d{2,4})$/);
      if (m){ const dd=Number(m[1]); const mesKey = m[2].toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); const mm = meses[mesKey]; const yyRaw = m[3]; const yy = Number(yyRaw.length===2 ? ('20'+yyRaw) : yyRaw); if (isFinite(dd) && mm!=null && isFinite(yy)){ const d=new Date(yy,mm,dd); return d.getTime(); } }
      // ISO or YYYY-MM-DD
      const t = Date.parse(str); return isNaN(t) ? NaN : t;
    }

    function cmp(a,b){ if (a==null && b==null) return 0; if (a==null) return -1; if (b==null) return 1; if (a<b) return -1; if (a>b) return 1; return 0; }

    function sortRows(headers, rows){
      if (sortIndex < 0) return rows;
      const idx = sortIndex;
      // heuristic: date-aware and numeric-aware
      const sample = rows.find(r => r[idx] != null && String(r[idx]).trim() !== '');
      const sampleVal = sample ? sample[idx] : '';
      const sampleDate = parseDate(sampleVal);
      const isDate = !isNaN(sampleDate);
      const isNumeric = !isDate && !isNaN(parseFloat(String(sampleVal).replace(/,/g,'')));
      const dir = (sortDir === 'asc') ? 1 : -1;
      return rows.slice().sort((ra, rb) => {
        const va = ra[idx]; const vb = rb[idx];
        if (isDate) { const da = parseDate(va); const db = parseDate(vb); return dir * (cmp(da, db)); }
        if (isNumeric) { const na = parseFloat(String(va).replace(/,/g,'')); const nb = parseFloat(String(vb).replace(/,/g,'')); return dir * (cmp(na, nb)); }
        return dir * (cmp(String(va||'').toLowerCase(), String(vb||'').toLowerCase()));
      });
    }

    function applyAndRender(headers, allRows){
      try {
        // build objects to preserve master indices
        const objs = allRows.map((r,i)=>({r,i}));
        const filteredObjs = objs.filter(o => applyFilter(headers, [o.r]).length>0);
        const sortedObjs = filteredObjs.slice().sort((a,b)=>{
          const idx = sortIndex;
          if (idx == null || idx < 0) return 0;
          const sampleDate = parseDate((a.r[idx]||'')); const sampleDateB = parseDate((b.r[idx]||''));
          const isDate = !isNaN(sampleDate) || !isNaN(sampleDateB);
          const isNumeric = !isDate && (!isNaN(parseFloat(String(a.r[idx]).replace(/,/g,''))) || !isNaN(parseFloat(String(b.r[idx]).replace(/,/g,''))));
          const dir = (sortDir === 'asc') ? 1 : -1;
          const va = a.r[idx]; const vb = b.r[idx];
          if (isDate) { const da = parseDate(va); const db = parseDate(vb); return dir * (cmp(da, db)); }
          if (isNumeric) { const na = parseFloat(String(va).replace(/,/g,'')); const nb = parseFloat(String(vb).replace(/,/g,'')); return dir * (cmp(na, nb)); }
          return dir * (cmp(String(va||'').toLowerCase(), String(vb||'').toLowerCase()));
        });
        window._pct2ViewIndices = sortedObjs.map(o=>o.i);
        const sorted = sortedObjs.map(o=>o.r);
        render(headers, sorted);
        enableEditingSimple();
      } catch {}
    }

    function fixTipoPrueba(headers, rows){
      const idx = headers.findIndex(h => String(h||'').trim().toLowerCase() === 'tipo de prueba');
      if (idx < 0) return rows;
      return rows.map(r => {
        const v = String(r[idx] == null ? '' : r[idx]).trim();
        let nv = v;
        if (/^p\.t$/i.test(v)) nv = 'L.P';
        else if (/^l\.p$/i.test(v)) nv = 'P.T';
        if (nv !== v) { const rr = r.slice(); rr[idx] = nv; return rr; }
        return r;
      });
    }

    function printVisible(){
      const w = window.open('', '_blank'); if (!w) return;
      const doc = w.document;
      const style = doc.createElement('style');
      style.textContent = 'body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:16px;} table{width:100%;border-collapse:collapse;} th,td{border:1px solid #ccc;padding:6px 8px;text-align:left;} thead th{background:#f6f7f9;} h1{font-size:18px;margin:0 0 12px;}';
      doc.head.appendChild(style);
      const h1 = doc.createElement('h1'); h1.textContent = 'PCT2 – Registro 2023'; doc.body.appendChild(h1);
      const table = doc.createElement('table');
      // header
      const thead = doc.createElement('thead'); const trh = doc.createElement('tr');
      Array.from(document.querySelectorAll('#thead th')).forEach(th0 => { const th=doc.createElement('th'); th.textContent = th0.textContent; trh.appendChild(th); });
      thead.appendChild(trh); table.appendChild(thead);
      // body
      const tbody = doc.createElement('tbody');
      Array.from(document.querySelectorAll('#tbody tr')).forEach(tr0 => {
        const tr = doc.createElement('tr');
        Array.from(tr0.children).forEach(td0 => { const td = doc.createElement('td'); td.textContent = td0.textContent; tr.appendChild(td); });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody); doc.body.appendChild(table);
      setTimeout(()=>{ try{ w.focus(); w.print(); } catch{} }, 300);
    }

    function enableEditingSimple(){
      try {
        const tbody = document.getElementById('tbody');
        if (!tbody) return;
        // Detect indices for live recalculation
        const headers = getHeaders();
        let idxFecha = -1, idxDias = -1, idxReal = -1;
        try {
          headers.forEach((h,i)=>{
            const n = String(h||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim();
            if (idxReal<0 && n === 'fecha realizacion') idxReal = i;
            if (idxFecha<0 && n === 'proxima prueba') idxFecha = i;
            if (idxDias<0 && n === 'dias de vigencia') idxDias = i;
          });
          headers.forEach((h,i)=>{
            const n = String(h||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
            if (idxFecha<0 && (n.includes('proxima') || n.includes('próxima')) && n.includes('prueba')) idxFecha = i;
            if (idxDias<0 && (n.includes('dias') || n.includes('días')) && n.includes('vigencia')) idxDias = i;
            if (idxReal<0 && n.includes('fecha') && (n.includes('realizacion') || n.includes('realización'))) idxReal = i;
          });
        } catch {}
        tbody.querySelectorAll('td').forEach(td => {
          td.setAttribute('contenteditable','true');
          td.setAttribute('inputmode','text');
        });
        // Live recalc on input for date columns
        if (idxDias>=0 && idxFecha>=0 && idxReal>=0){
          tbody.addEventListener('input', (e) => {
            const td = e.target.closest('td'); if (!td) return;
            const tr = td.parentElement; if (!tr) return;
            const cIdx = Number(td.dataset.colIndex||-1); if (cIdx<0) return;
            if (cIdx === idxFecha || cIdx === idxReal){
              const tds = Array.from(tr.children);
              const fechaProx = tds[idxFecha]?.textContent || '';
              const fechaReal = tds[idxReal]?.textContent || '';
              const d = (window.vigenciaDays ? window.vigenciaDays(fechaProx, fechaReal) : (function(fp, fr){
                try { const tp = parseDate(fp), tr = parseDate(fr); if (isNaN(tp)||isNaN(tr)) return null; return Math.floor((tp-tr)/(1000*60*60*24)); } catch { return null; }
              })(fechaProx, fechaReal));
              if (idxDias < tds.length){ tds[idxDias].textContent = (d==null || isNaN(d)) ? '' : String(d); }
              // Debounced KPI update
              clearTimeout(window._kpiDebounce);
              window._kpiDebounce = setTimeout(updateTopKPIFromDOM, 200);
            }
          });
        }
      } catch {}
    }

    let dataMaster = [];
    async function start(){
      const metaEl = $('#meta');
      try {
        const res = await fetch(SRC, { cache: 'no-cache' });
        if (!res.ok){ throw new Error('No se pudo cargar CSV'); }
        const txt = await res.text();
        const rows = parseCSV(txt);
        const hdrIdx = findHeaderIndex(rows);
        const metaRows = rows.slice(0, hdrIdx).filter(r => r.some(c=>String(c||'').trim()));
        const headers = rows[hdrIdx].map(h=>String(h||'').trim());
        let data = rows.slice(hdrIdx+1).filter(r => r.some(c=>String(c||'').trim()));
        data = fixTipoPrueba(headers, data);
        if (metaRows.length){
          const flat = metaRows.map(r=>r.filter(c=>String(c||'').trim()).join(' ')).filter(s=>s).join(' • ');
          metaEl.innerHTML = flat ? ('<span class="badge">Meta</span> ' + flat) : '';
        }
        dataMaster = data;
        window._pct2Headers = headers;
        // populate sort select
        const sel = $('#sortCol');
        sel.innerHTML = '<option value="">Ordenar por…</option>' + headers.map((h,i)=>`<option value="${i}">${h}</option>`).join('');
        // default: try to auto-select a date-ish column
        const likelyDateIdx = headers.findIndex(h => /fecha|date/i.test(h));
        if (likelyDateIdx >= 0) { sortIndex = likelyDateIdx; sortDir = 'desc'; sel.value = String(likelyDateIdx); }
        // ensure search is clear to avoid empty filtered view
        try { const s = $('#search'); if (s) s.value = ''; } catch {}
        // Load locally saved view if compatible (persisted by saveEdits)
        try {
          const raw = localStorage.getItem('pct2_data_v1');
          if (raw){
            const saved = JSON.parse(raw);
            if (Array.isArray(saved?.headers) && saved.headers.length === headers.length && Array.isArray(saved?.data) && saved.data.length>0){
              dataMaster = saved.data;
            }
          }
        } catch {}
        applyAndRender(headers, dataMaster);
        try { setTimeout(updateTopKPIFromDOM, 0); } catch {}
        $('#search').addEventListener('input', () => { applyAndRender(headers, dataMaster); try { clearTimeout(window._kpiDebounce); window._kpiDebounce = setTimeout(updateTopKPIFromDOM, 150); } catch {} });
        $('#btnAsc').addEventListener('click', () => { if (sortIndex>=0){ sortDir='asc'; applyAndRender(headers, dataMaster);} });
        $('#btnDesc').addEventListener('click', () => { if (sortIndex>=0){ sortDir='desc'; applyAndRender(headers, dataMaster);} });
        sel.addEventListener('change', (e) => { const v = String(e.target.value||''); sortIndex = v ? Number(v) : -1; applyAndRender(headers, dataMaster); });
        $('#btnExport').addEventListener('click', () => exportVisible(headers));
        $('#btnPrint').addEventListener('click', () => printVisible());
        bindSaveButton();
      } catch (e){
        metaEl.textContent = 'Error: ' + (e?.message || '');
        $('#tbody').innerHTML = '<tr><td class="muted">No se pudo cargar el CSV</td></tr>';
      }
    }
    start();

    function bindSaveButton(){
      try {
        const btn = document.getElementById('btnSave');
        if (!btn) return;
        if (btn.dataset.bound === '1') return;
        btn.addEventListener('click', async () => {
          const prev = btn.textContent;
          try {
            btn.textContent = 'Guardando…';
            // Primero sincroniza ediciones y recálculo
            saveEdits();
            // Luego guarda en Firestore (pctvenc)
            const ok = await saveToFirestoreVenc();
            btn.textContent = ok ? 'Guardado ✓' : 'Error al guardar';
            setTimeout(() => { try { btn.textContent = prev; } catch {} }, 1400);
          } catch (e) {
            try { btn.textContent = 'Guardar'; } catch {}
            try { console.warn('[pct2] save click error', e?.message); } catch {}
          }
        });
        btn.dataset.bound = '1';
      } catch {}
    }
    // Fallback bind in case start() aborts early
    try { if (document.readyState !== 'loading') bindSaveButton(); else document.addEventListener('DOMContentLoaded', bindSaveButton); } catch {}

    async function saveToFirestoreVenc(){
      try {
        const headers = Array.from(document.querySelectorAll('#thead th')).map(th => th.textContent.trim());
        let rows = Array.isArray(dataMaster) && dataMaster.length ? dataMaster : Array.from(document.querySelectorAll('#tbody tr')).map(tr => Array.from(tr.children).map(td => td.textContent || ''));
        if (!Array.isArray(rows) || rows.length === 0) return false;
        // Convert to array of objects (avoid nested arrays which Firestore rejects)
        const rowsObj = rows.map(r => {
          const o = {};
          for (let i=0;i<headers.length;i++){ o[headers[i]] = (r && r[i] != null) ? String(r[i]) : ''; }
          return o;
        });
        const payload = {
          savedAtLocal: new Date().toISOString(),
          headers,
          rows: rowsObj,
          user: window.currentUser ? { uid: window.currentUser.uid, email: window.currentUser.email || null } : null,
          source: 'pct2_csv_2023'
        };
        const mod = await import('https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js');
        const db = window.db;
        if (!db) { console.warn('[pct2] Firestore DB not initialized'); return false; }
        try {
          await mod.addDoc(mod.collection(db, 'pctvenc'), { ...payload, savedAt: mod.serverTimestamp() });
          return true;
        } catch (e1){
          console.warn('[pct2] root pctvenc write failed, trying user namespace', e1?.message);
          const uid = window.currentUser?.uid || null;
          if (!uid) throw e1;
          const userDoc = mod.doc(mod.collection(db, 'users'), String(uid));
          await mod.setDoc(userDoc, { uid: String(uid) }, { merge: true });
          await mod.addDoc(mod.collection(userDoc, 'pctvenc'), { ...payload, savedAt: mod.serverTimestamp() });
          return true;
        }
      } catch (e){ console.warn('[pct2] saveToFirestoreVenc error', e?.message); return false; }
    }

    function saveEdits(){
      try {
        console.log('[pct2] saveEdits invoked');
        const tbody = document.getElementById('tbody');
        if (!tbody) return;
        let headers = Array.from(document.querySelectorAll('#thead th')).map(th => th.textContent.trim());
        // Detect indices por nombre
        let idxFecha = -1, idxDias = -1, idxReal = -1;
        headers.forEach((h,i)=>{
          const n = (h||'').toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim();
          if (idxReal<0 && n === 'fecha realizacion') idxReal = i;
          if (idxFecha<0 && n === 'proxima prueba') idxFecha = i;
          if (idxDias<0 && n === 'dias de vigencia') idxDias = i;
        });
        headers.forEach((h,i)=>{
          const n = (h||'').toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
          if (idxFecha<0 && (n.includes('proxima') || n.includes('próxima')) && n.includes('prueba')) idxFecha = i;
          if (idxDias<0 && (n.includes('dias') || n.includes('días')) && n.includes('vigencia')) idxDias = i;
          if (idxReal<0 && n.includes('fecha') && (n.includes('realizacion') || n.includes('realización'))) idxReal = i;
        });
        const trsProbe = Array.from(tbody.querySelectorAll('tr'));
        // Si no detectamos Próxima por nombre, buscar la columna a la derecha que más parezca fecha
        if (trsProbe.length){
          if (idxFecha < 0) idxFecha = detectBestDateColBySample(tbody);
          if (idxReal < 0) idxReal = detectBestDateColBySample(tbody);
        }
        // Si no existe 'Días de vigencia', crear la columna al final
        if (idxDias < 0){
          const theadTr = document.querySelector('#thead');
          if (theadTr){ const th = document.createElement('th'); th.textContent = 'DÍAS DE VIGENCIA'; th.classList.add('sortable'); theadTr.appendChild(th); }
          trsProbe.forEach(tr => { const td = document.createElement('td'); td.textContent=''; tr.appendChild(td); });
          headers = Array.from(document.querySelectorAll('#thead th')).map(th => th.textContent.trim());
          idxDias = headers.length - 1;
        }
        // Update DOM "Días de vigencia" if column exists
        const trs = trsProbe;
        trs.forEach(tr => {
          const tds = Array.from(tr.children);
          if (idxFecha>=0 && idxReal>=0 && idxFecha < tds.length && idxReal < tds.length){
            const fechaProx = tds[idxFecha]?.textContent || '';
            const fechaReal = tds[idxReal]?.textContent || '';
            const d = vigenciaDays(fechaProx, fechaReal);
            if (idxDias>=0 && idxDias < tds.length){
              tds[idxDias].textContent = (d==null || isNaN(d)) ? '' : String(d);
            }
          }
        });
        // Build current view from DOM
        const viewRows = trs.map(tr => Array.from(tr.children).map(td => td.textContent || ''));
        // Sync DOM edits back to dataMaster preserving original indices
        try {
          const headersLen = headers.length;
          // Ensure dataMaster has the right shape
          if (!Array.isArray(dataMaster)) dataMaster = [];
          trs.forEach((tr, i) => {
            const masterIdxStr = tr.getAttribute('data-master-index');
            const mIdx = masterIdxStr != null ? Number(masterIdxStr) : (window._pct2ViewIndices ? window._pct2ViewIndices[i] : i);
            const rowVals = viewRows[i];
            if (mIdx != null && !isNaN(mIdx) && Array.isArray(rowVals)){
              const normalized = Array.from({length: headersLen}, (_, c) => String(rowVals[c] == null ? '' : rowVals[c]));
              dataMaster[mIdx] = normalized;
            }
          });
          // Persist to localStorage
          try { localStorage.setItem('pct2_data_v1', JSON.stringify({ headers, data: dataMaster })); } catch {}
        } catch {}
        // Refresh view: re-render with updated dataMaster to recompute and reflect DÍAS DE VIGENCIA
        try { applyAndRender(window._pct2Headers || headers, dataMaster); } catch { renderSummary(headers, viewRows); }
        try { setTimeout(updateTopKPIFromDOM, 0); } catch {}
        // Feedback
        try { const btn = document.getElementById('btnSave'); if (btn){ const t=btn.textContent; btn.textContent='Guardado ✓'; setTimeout(()=>btn.textContent=t, 1200); } } catch{}
      } catch {}
    }
  </script>
</body>
</html>
